#!/bin/bash

# enable bash debugging
KMDBSCRIPT="${KMDBSCRIPT:=0}"
if [ $KMDBSCRIPT == "1" ]
then
  set -x
fi

# directory where files are dumped
KMDUMPDIR="${KMDUMPDIR:=.}"

# dump the LLVM bitcode
KMDUMPLLVM="${KMDUMPLLVM:=0}"

# dump the isa
KMDUMPISA="${KMDUMPISA:=0}"

# pass extra options to OPT
# KMOPTOPT can be used to pass last-minute options to opt in the backend
# if not set, then "-O3" would be passed to opt
KMOPTOPT="${KMOPTOPT:="-O3"}"

# pass extra options to LLC
# KMOPTLLC can be used to pass last-minute options to llc in the backend
# if not set, then 2 will be passed to llc
KMOPTLLC="${KMOPTLLC:=2}"

# enable LLVM hijacking
KMHACKLLVM="${KMHACKLLVM:=0}"

# determine if we want to use ThinLTO
KMTHINLTO="${KMTHINLTO:=0}"

# check number of arguments
if [ "$#" -eq 0 ]; then
  echo "$0 is NOT recommended to be directly used" >&2
  exit 1
fi

# enable bundle dumping
KMDUMPBUNDLE="${KMDUMPBUNDLE:=0}"

BINDIR=$(dirname $0)
LINK=$BINDIR/llvm-link
LTO=$BINDIR/llvm-lto
SPLIT=$BINDIR/llvm-split
OPT=$BINDIR/opt
LOAD_PASS_LIB=$BINDIR/../lib
CLAMP_DEVICE=$BINDIR/clamp-device
LLD=$BINDIR/ld.lld
CLAMP_EMBED=$BINDIR/clamp-embed
CLANG_OFFLOAD_BUNDLER=$BINDIR/clang-offload-bundler

################
# Verbose flag
################

VERBOSE=0

################
# GPU targets
# This array could be populated via 3 methods:
# 1) clang driver adds multiple --amdgpu-target=<GPU target> options
# 2) HCC_AMDGPU_TARGET env var, multiple targets are delimited by ",".
#    Example:
#
#    export HCC_AMDGPU_TARGET=gfx701,gfx801,gfx802,gfx803
#    # ISA for Hawaii(gfx701), Carrizo(gfx801), Tonga(gfx802) and Fiji(gfx803)
#    # would be produced
#    hcc `hcc-config --cxxflags --ldflags` foo.cpp
#
# 3) CMake AMDGPU_TARGET config value. This is the last resort options.
################

AMDGPU_TARGET_ARRAY=()

################
# link
################

LINK_KERNEL_ARGS=()
LINK_HOST_ARGS=()
LINK_CPU_ARG=()
LINK_OTHER_ARGS=()

TEMP_DIR=`mktemp -d`

# a file which contains the list of __cxxamp_serialize symbols in each CPU object file
CXXAMP_SERIALIZE_SYMBOL_FILE=$TEMP_DIR/symbol.txt
touch $CXXAMP_SERIALIZE_SYMBOL_FILE

# determine `file` output per host architecture
if [[ "@CMAKE_SYSTEM_PROCESSOR@" == "x86_64" ]]; then
  OBJ_FILE_FORMAT_STRING="ELF 64-bit LSB  relocatable, x86-64"
elif [[ "@CMAKE_SYSTEM_PROCESSOR@" == "aarch64" ]]; then
  OBJ_FILE_FORMAT_STRING="ELF 64-bit LSB  relocatable, ARM aarch64"
elif [[ "@CMAKE_SYSTEM_PROCESSOR@" == "ppc64" ]]; then
  OBJ_FILE_FORMAT_STRING="ELF 64-bit LSB  relocatable, ppc64"
elif [[ "@CMAKE_SYSTEM_PROCESSOR@" == "ppc64le" ]]; then
  OBJ_FILE_FORMAT_STRING="ELF 64-bit LSB  relocatable, ppc64le"
else
  OBJ_FILE_FORMAT_STRING="ELF 64-bit LSB  relocatable"
fi

# find object file
_find_object() {
  local FILE=$1
  local ret=${FILE%.o}

  if [ -e $FILE ]; then
    local file_output=`file $FILE | grep "$OBJ_FILE_FORMAT_STRING"`
    local readelf_output=`readelf -h $FILE 2>&1 | grep 'Relocatable file'`

    if [ ! -z "$file_output" ] && [ ! -z "$readelf_output" ]; then
      # remove postfix
      ret=${FILE%.*}
    fi
  fi

  echo $ret
}

ARGS="$@"
STATIC_LIB_LIST=()
TEMP_AR_DIRS=()

# detect the verbose flags before doing anything
if [[ "$ARGS" =~ --verbose ]]; then
  VERBOSE=1
fi
#very verbose
#VERBOSE=2

# This ThinLTO helper function performs the ThinLTO Link Time for the specified AMDGPU target.
# Using a helper function allows us to launch multiple helper functions in parallel for different gfx targets.
_thinlto_target_helper() {

  local AMDGPU_TARGET=$1

  # prepare the rocdl libraries to be linked
  HCC_BC_LIBS="$ROCM_LIB/hc.amdgcn.bc $ROCM_LIB/opencl.amdgcn.bc $ROCM_LIB/ocml.amdgcn.bc $ROCM_LIB/ockl.amdgcn.bc $ROCM_LIB/irif.amdgcn.bc $ROCM_LIB/oclc_finite_only_off.amdgcn.bc $ROCM_LIB/oclc_daz_opt_off.amdgcn.bc $ROCM_LIB/oclc_correctly_rounded_sqrt_on.amdgcn.bc $ROCM_LIB/oclc_unsafe_math_off.amdgcn.bc"
  HCC_EXTRA_ARCH_FILE=""
  # select appropriate ROCm-Device-Libs per AMDGPU_TARGET
  if [ $AMDGPU_TARGET == "gfx700" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_700.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX700
  elif [ $AMDGPU_TARGET == "gfx701" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_701.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX701
  elif [ $AMDGPU_TARGET == "gfx801" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_801.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX801
  elif [ $AMDGPU_TARGET == "gfx802" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_802.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX802
  elif [ $AMDGPU_TARGET == "gfx803" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_803.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX803
  elif [ $AMDGPU_TARGET == "gfx900" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_900.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX900
  elif [ $AMDGPU_TARGET == "gfx901" ]; then
    OCLC_ISA_VERSION_LIB="$ROCM_LIB/oclc_isa_version_901.amdgcn.bc"
    HCC_EXTRA_ARCH_FILE=$HCC_EXTRA_LIBRARIES_GFX901
  fi
  HCC_BC_LIBS="$HCC_BC_LIBS $OCLC_ISA_VERSION_LIB $HCC_EXTRA_LIBRARIES $HCC_EXTRA_ARCH_FILE"

  # prepare all kernels for opt and llc passes by linking with rocdl library
  declare -a LINK_IMPORTED_KERNEL_ARGS
  for KERNEL in ${LinkKernels[@]}
  do
    LINK_IMPORTED_KERNEL_ARGS+=( $KERNEL-$AMDGPU_TARGET.imported.bc )
    $LINK -suppress-warnings -o $KERNEL-$AMDGPU_TARGET.imported.bc $KERNEL.thinlto.imported.bc $HCC_BC_LIBS
  done

  if [ $VERBOSE != 0 ]; then
    echo "Imported Kernels: ${LINK_IMPORTED_KERNEL_ARGS[@]}"
    echo ""
  fi

  # perform parallel opt and llc in-program llvm-lto and
  # specify the opt and codegen passes to be added
  $LTO -thinlto -thinlto-action=optllc "${LINK_IMPORTED_KERNEL_ARGS[@]}" -load $LOAD_PASS_LIB/LLVMSelectAcceleratorCode@CMAKE_SHARED_LIBRARY_SUFFIX@ -select-accelerator-code -dce -globaldce -always-inline -mtriple amdgcn--amdhsa-amdgiz -mcpu=$AMDGPU_TARGET -infer-address-spaces -amdgpu-internalize-symbols -lto-freestanding -enable-si-insert-waitcnts=0 $KMOPTOPT -codegen-opt-level=$KMOPTLLC -thinlto-save-temps="$TEMP_DIR/"

  # since thinlto has multiple kernel files, we will dump all the optimized kernel files
  if [ $KMDUMPLLVM == "1" ]; then
    for f in $TEMP_DIR/*.1.opt.bc; do bn="${f##*/}"; cp "$f" "${KMDUMPDIR}/dump-$AMDGPU_TARGET.${bn%%.*}.opt.bc"; done
  fi

  # there are multiple kernels that underwent codegen as well, we will dump all of their isa files
  if [ $KMDUMPISA == "1" ]; then
    $LTO -thinlto -thinlto-action=optllc "${LINK_IMPORTED_KERNEL_ARGS[@]}" -load $LOAD_PASS_LIB/LLVMSelectAcceleratorCode@CMAKE_SHARED_LIBRARY_SUFFIX@ -select-accelerator-code -dce -globaldce -always-inline -mtriple amdgcn--amdhsa-amdgiz -mcpu=$AMDGPU_TARGET -infer-address-spaces -amdgpu-internalize-symbols -lto-freestanding -dump-isa -enable-si-insert-waitcnts=0 $KMOPTOPT -codegen-opt-level=$KMOPTLLC
    for f in $TEMP_DIR/*.thinlto.isa; do bn="${f##*/}"; cp "$f" "${KMDUMPDIR}/dump-$AMDGPU_TARGET.${bn%%.*}.isa"; done
  fi

  declare -a ISABIN_FILES
  # collect the ISABIN files for lld linking
  for KERNEL in ${LINK_IMPORTED_KERNEL_ARGS[@]}
  do
    ISABIN_FILES+=( $KERNEL.thinlto.isabin )
  done

  if [ $VERBOSE != 0 ]; then
    echo "ISABIN Kernels: ${ISABIN_FILES[@]}"
    echo ""
  fi

  # combine all ISABIN files into HSACO format
  $LLD -shared ${ISABIN_FILES[@]} -o $2
  ret=$?
  if [ $ret != 0 ]; then
    echo "Generating AMD GCN kernel failed in ld.lld for target: $AMDGPU_TARGET"
    exit $ret
  fi
  if [ $KMDUMPISA == "1" ]; then
    cp $2 ${KMDUMPDIR}/dump-$AMDGPU_TARGET.hsaco
  fi

  if [ $VERBOSE != 0 ]; then
    echo "Generated: $2"
    echo ""
  fi
  unset ISABIN_FILES
  unset LINK_IMPORTED_KERNEL_ARGS
}

# Using ThinLTO for performing opt and codegen on kernels in parallel
_thinlto_path() {

  if [ $VERBOSE != 0 ]; then
    echo "Generating AMD GCN Kernels: ${LINK_KERNEL_ARGS[@]}"
    echo ""
  fi

  ################
  # Determine the ROCm device libs path
  ################

  ROCM_DEVICE_LIBS_SEARCH_PATHS="@ROCM_DEVICE_LIB_PATHS@"
  ROCM_LIB=""
  for SEARCH_PATH in $(echo $ROCM_DEVICE_LIBS_SEARCH_PATHS | tr ";" "\n")
  do
    if [ -f "$SEARCH_PATH/ocml.amdgcn.bc" ]; then
      ROCM_LIB=$SEARCH_PATH
      break
    fi
  done
  if [ ! -f "$ROCM_LIB/ocml.amdgcn.bc" ]; then
    echo "ROCm Device Libs is missing"
    exit 1
  fi

  unset LinkKernels
  LinkKernels=()
  NUM_SPLIT=4
  NUM_KERNS_THRESHOLD=1000
  # for each kernel, decide if we want to split the kernel file into multiple
  for KERNEL in ${LINK_KERNEL_ARGS[@]} ; do
    if [ $VERBOSE != 0 ]; then
      echo "Splitting Kernel: ${KERNEL}"
    fi

    # Using llvm-split, perform kernel splitting and return number of kernels in the file
    NUM_KERNELS=`$SPLIT "${KERNEL}" -o "${KERNEL}" -split-hcc-kernels -split-hcc-threshold $NUM_KERNS_THRESHOLD -j $NUM_SPLIT`

    if [ $VERBOSE != 0 ]; then
      echo "Num Kerns: $NUM_KERNELS Num Kerns Threshold: $NUM_KERNS_THRESHOLD"
    fi

    # If number of kernels in the file exceeds the threshold, we will need to add each sub file into the array for LTO later
    # Otherwise we will generate the module summary for the original kernel file for ThinLTO indexing later
    if [ $NUM_KERNELS -le $NUM_KERNS_THRESHOLD ]; then
      $OPT -thinlto-bc -disable-opt -module-summary $KERNEL -o $KERNEL
      LinkKernels+=( "$KERNEL" )
    else
      if [ $VERBOSE != 0 ]; then
        echo "  Splitted Number of Files: $NUM_SPLIT"
      fi
      for ((SUBKERNEL=0; SUBKERNEL < NUM_SPLIT; SUBKERNEL++)) ; do
        $OPT -thinlto-bc -disable-opt -module-summary $KERNEL$SUBKERNEL -o $KERNEL$SUBKERNEL.bc
        LinkKernels+=( "$KERNEL$SUBKERNEL.bc" )
      done
    fi
  done

  if [ $VERBOSE != 0 ]; then
    echo "Splitted Kernels: ${LinkKernels[@]}"
    echo ""
  fi

  # perform ThinLTO indexing and cross-module importing
  $LTO -thinlto -thinlto-action=thinlink "${LinkKernels[@]}" -o $TEMP_DIR/kernel.thinlto.index
  $LTO -thinlto -thinlto-action=import "${LinkKernels[@]}" -thinlto-index=$TEMP_DIR/kernel.thinlto.index -import-instr-limit=1048576 -force-import-weak

  declare -a pids
  # for each GPU target, lower LLVM IR kernels into GCN ISA in parallel
  for AMDGPU_TARGET in ${AMDGPU_TARGET_ARRAY[@]}
  do
    { _thinlto_target_helper $AMDGPU_TARGET $TEMP_DIR/kernel-$AMDGPU_TARGET.hsaco; } &

    # error handling
    pids=("${pids[@]}" "$!")

    # augment arguments to clang-offload-bundler
    CLANG_OFFLOAD_BUNDLER_INPUTS_ARGS+=",$TEMP_DIR/kernel-$AMDGPU_TARGET.hsaco"
    CLANG_OFFLOAD_BUNDLER_TARGETS_ARGS+=",hcc-amdgcn--amdhsa-$AMDGPU_TARGET"
  done

  # collect all the error codes from forked processes
  # error handling
  for pid in ${pids[*]}; do
    wait $pid || ret=$((ret+$?))
  done
  unset pids
  if [ $ret != 0 ]; then
    exit $ret
  fi
}

# Using default path for link-time opt and llc in clamp-device
_default_path() {

  # combine kernel sections together
  $LINK "${LINK_KERNEL_ARGS[@]}" | $OPT -always-inline - -o $TEMP_DIR/kernel.bc

  if [ $VERBOSE == 1 ]; then
    echo "Generating AMD GCN kernel"
  fi

  declare -a pids
  # for each GPU target, lower to GCN ISA in HSACO format
  for AMDGPU_TARGET in ${AMDGPU_TARGET_ARRAY[@]}; do
    { $CLAMP_DEVICE $TEMP_DIR/kernel.bc $TEMP_DIR/kernel-$AMDGPU_TARGET.hsaco --amdgpu-target=$AMDGPU_TARGET; } &

    # error handling
    pids=("${pids[@]}" "$!")

    # augment arguments to clang-offload-bundler
    CLANG_OFFLOAD_BUNDLER_INPUTS_ARGS+=",$TEMP_DIR/kernel-$AMDGPU_TARGET.hsaco"
    CLANG_OFFLOAD_BUNDLER_TARGETS_ARGS+=",hcc-amdgcn-amd-amdhsa--$AMDGPU_TARGET"
  done

  # collect all the error codes from forked processes
  # error handling
  for pid in ${pids[*]}; do
    wait $pid || ret=$((ret+$?))
  done
  unset pids
  if [ $ret != 0 ]; then
    exit $ret
  fi
}

# gather a list of library search paths
LIB_SEARCH_PATHS=()
for ARG in "$@"
do
  # matches -L<path>
  if [[ "$ARG" =~ ^-L.* ]]; then
    REAL_PATH="$(readlink -f "${ARG:2}")"
    if [ $VERBOSE == 2 ]; then
      echo "add library path: ${ARG:2}, canonical path: $REAL_PATH"
    fi
    LIB_SEARCH_PATHS+=( "$REAL_PATH" )
  fi
done

# gather input arguments from linker command files
INPUT_ARGUMENTS=()
for ARG in "$@"
do
  # matches @<path>
  if [[ "$ARG" =~ ^@.* ]]; then
    REAL_PATH="$(readlink -f "${ARG:1}")"
    if [ $VERBOSE == 2 ]; then
      echo "add linker command path: ${ARG:1}, canonical path: $REAL_PATH"
    fi

    # read from linker command file
    IFS=$'\n' read -d '' -r -a LINES < "$REAL_PATH"
    for LINE in ${LINES[@]}
    do
      if [ $VERBOSE == 2 ]; then
        echo "add linker command: $LINE"
      fi
      INPUT_ARGUMENTS+=($LINE)
    done
  else
    INPUT_ARGUMENTS+=("$ARG")
  fi
done

for ARG in "${INPUT_ARGUMENTS[@]}"
do

  case $ARG in
    ######################
    # Parse AMDGPU target
    ######################
    --amdgpu-target=*)
    AMDGPU_TARGET_ARRAY+=("${ARG#*=}")
    continue
    ;;
    ################################################
    # Parse dump options and export them for called
    # scripts e.g. clamp-device
    ################################################
    --hcc-extra-libs=*)
    HCC_EXTRA_LIBRARIES="$HCC_EXTRA_LIBRARIES ${ARG#*=}"
    continue
    ;;
    -dump-isa)
    export KMDUMPISA=1
    continue
    ;;
    -dump-llvm)
    export KMDUMPLLVM=1
    continue
    ;;
    -dump-dir=*)
    export KMDUMPDIR="${ARG#*=}"
    continue
    ;;
  esac

  #####################################
  # detect object or static library
  #####################################

  OBJS_TO_PROCESS=()


  if [[ "$ARG" =~ [^[:space:]]+\.cpu$ ]]; then

    cp "$ARG" $TEMP_DIR/kernel_cpu.o
    LINK_CPU_ARG+=( "$TEMP_DIR/kernel_cpu.o" )

  elif [[ "$ARG" =~ [^[:space:]]+\.o$ ]]; then
    # detected a .o file
    if [ $VERBOSE == 2 ]; then
      echo "detect object file to process further: $ARG"
    fi

    OBJS_TO_PROCESS+=( "$ARG" )
  elif [[ "$ARG" =~ ^-l[^[:space:]]+$ ]] || [[ "$ARG" =~ [^[:space:]]+.a$ ]] || [[ "$ARG" =~ [^[:space:]]+.lo$ ]]; then

    # proccess a static library

    DETECTED_STATIC_LIBRARY=""

    # detected whether it's an -l<library naem> option
    if [[ "$ARG" =~ ^-l[^[:space:]]+$ ]]; then

      # expand the option into a library name
      STATIC_LIB_NAME="lib${ARG:2}.a"

      if [ $VERBOSE == 2 ]; then
        echo "looking for static library $STATIC_LIB_NAME"
      fi

      # look for the static library in the library search paths
      for LIB_PATH in "${LIB_SEARCH_PATHS[@]}"
      do
        FULL_LIB_PATH="$LIB_PATH"
        FULL_LIB_PATH+="/"
        FULL_LIB_PATH+="$STATIC_LIB_NAME"
        FULL_LIB_PATH=$(readlink -f "$FULL_LIB_PATH")
        if [ $VERBOSE == 2 ]; then
          echo "trying to detect $FULL_LIB_PATH"
        fi
        if [ -f "$FULL_LIB_PATH" ]; then
          if [ $VERBOSE == 2 ]; then
            echo "$FULL_LIB_PATH detected"
          fi
          DETECTED_STATIC_LIBRARY="$FULL_LIB_PATH";
          break;
        fi
      done
    else
      # this is .a or .lo static library file specified at the commad line
      if [ -f "$ARG" ]; then
        FULL_LIB_PATH=$(readlink -f "$ARG")
        if [ $VERBOSE == 2 ]; then
          echo "use .a / .lo specified at: $FULL_LIB_PATH"
        fi
        DETECTED_STATIC_LIBRARY="$FULL_LIB_PATH"
      fi
    fi  # if [[ "$ARG" =~ ^-l[^[:space:]]+$ ]]; then


    # check for duplicated static library options
    if [[ $DETECTED_STATIC_LIBRARY != "" ]]; then
      for LIB in "${STATIC_LIB_LIST[@]}"
      do
        if [[ $LIB == $DETECTED_STATIC_LIBRARY ]]; then
          # this library has already been looked at, skip it
          DETECTED_STATIC_LIBRARY=""
          break;
        fi
      done
      if [[ $DETECTED_STATIC_LIBRARY != "" ]]; then
        STATIC_LIB_LIST+=( "$DETECTED_STATIC_LIBRARY" )
      fi
    fi


    KERNEL_UNDETECTED="1"
    if [[ $DETECTED_STATIC_LIBRARY != "" ]]; then

      # we found a static library library
      if [ $VERBOSE == 2 ]; then
        echo "processing static library $DETECTED_STATIC_LIBRARY"
      fi

      # detect whether the objects in the static library contain a .kernel section
      KERNEL_UNDETECTED=`objdump -t "$DETECTED_STATIC_LIBRARY" | grep -q "\.kernel"; echo $?`
      if [[ $KERNEL_UNDETECTED == "0" ]]; then

        # .kernel section detected, extract the objects from the archieve

        if [ $VERBOSE == 2 ]; then
          echo "kernel detected in $DETECTED_STATIC_LIBRARY"
        fi

        CURRENT_DIR=$PWD
        # extract the archive
        FILE=`basename $DETECTED_STATIC_LIBRARY`
        AR_TEMP_DIR="$TEMP_DIR"
        AR_TEMP_DIR+="/"
        AR_TEMP_DIR+="$FILE"

        if [ $VERBOSE == 2 ]; then
          echo "creating temp dir: $AR_TEMP_DIR"
        fi

        mkdir -p "$AR_TEMP_DIR"
        TEMP_AR_DIRS+=( "$AR_TEMP_DIR" )
        cd "$AR_TEMP_DIR"
        `ar x "$DETECTED_STATIC_LIBRARY"`

        cd "$CURRENT_DIR"

        # store all the extract objects to process further
        OBJS_TO_PROCESS=($(ls "$AR_TEMP_DIR"/*.o))

      fi  # if [[ $KERNEL_UNDETECTED == "0" ]]; then
    fi  # if [[ $DETECTED_STATIC_LIBRARY != "" ]]; then
  elif [ -f "$ARG" ]; then
    # an object file but doesn't have an .o extension??
    file_output=`file "$ARG" | grep "$OBJ_FILE_FORMAT_STRING"`
    readelf_output=`readelf -h "$ARG" 2>&1 | grep 'Relocatable file'`
    if [ ! -z "$file_output" ] && [ ! -z "$readelf_output" ]; then
      OBJS_TO_PROCESS+=( "$ARG" )
    fi
  fi


  # no objects to further process, pass the original args down to the host linker
  if [ ${#OBJS_TO_PROCESS[@]} == 0 ]; then
    # no objects to further process, pass the original args down to the host linker
    if [ $VERBOSE == 2 ]; then
      echo "passing down link args: $ARG"
    fi
    LINK_OTHER_ARGS+=( "$ARG" )
    continue
  fi

  # processs the objects we put aside
  for OBJ in "${OBJS_TO_PROCESS[@]}"
  do
    if [ $VERBOSE == 2 ]; then
      echo "processing $OBJ"
    fi

    # detect whether the objects in the static library contain a .kernel section
    KERNEL_UNDETECTED=`objdump -t "$OBJ" | grep -q "\.kernel"; echo $?`
    if [[ $KERNEL_UNDETECTED == "0" ]]; then

      FILE=`basename "$OBJ"` # remove path
      FILENAME="${FILE%.*}"
      KERNEL_FILE="$TEMP_DIR/$FILENAME.kernel.bc"
      HOST_FILE="$TEMP_DIR/$FILENAME.host.o"

      # extract kernel section
      objcopy -O binary -j .kernel "$OBJ" "$KERNEL_FILE"

      # extract host section
      objcopy -R .kernel "$OBJ" "$HOST_FILE"

      # strip all symbols specified in symbol.txt from $HOST_FILE
      objcopy @$CXXAMP_SERIALIZE_SYMBOL_FILE "$HOST_FILE" "$HOST_FILE.new" 2> /dev/null
      if [ -f "$HOST_FILE.new" ]; then
        mv "$HOST_FILE.new" "$HOST_FILE"
      fi

      # find cxxamp_serialize symbols and save them into symbol.txt
      objdump -t "$HOST_FILE" -j .text 2> /dev/null | grep "g.*__cxxamp_serialize" | awk '{print "-L"$6}' >> $CXXAMP_SERIALIZE_SYMBOL_FILE

      # if the kernel file is empty, just throw it away
      KERNEL_FILE_SIZE=$(wc -c < "$KERNEL_FILE")
      if [ "$KERNEL_FILE_SIZE" -ne "0" ]; then
        LINK_KERNEL_ARGS+=( "$KERNEL_FILE" )
      fi

      LINK_HOST_ARGS+=( "$HOST_FILE" )
    else
      LINK_OTHER_ARGS+=( "$OBJ" )
    fi


  done # for OBJ in "${OBJS_TO_PROCESS[@]}"
done

# AMDGPU_TARGET_ARRAY could be overridden by HCC_AMDGPU_TARGET env variable
if [ -n "$HCC_AMDGPU_TARGET" ]; then
  # tokenize HCC_AMDGPU_TARGET
  IFS=','
  HCC_AMDGPU_TARGET_TOKENS=($HCC_AMDGPU_TARGET)
  unset IFS
  # parse individual token, override AMDGPU_TARGET_ARRAY
  iter=0
  for HCC_AMDGPU_TARGET_TOKEN in ${HCC_AMDGPU_TARGET_TOKENS[@]}; do
    AMDGPU_TARGET_ARRAY[$iter]=$HCC_AMDGPU_TARGET_TOKEN
    ((iter++))
  done
fi

# In case neither Clang Driver nor HCC_AMDGPU_TARGET env var specify target,
# use default value in CMake configuration
if [ ${#AMDGPU_TARGET_ARRAY[@]} == 0 ]; then
  AMDGPU_TARGET_ARRAY=(@AMDGPU_TARGET@)
fi

if [ $VERBOSE != 0 ]; then
  echo "AMDGPU target array: "${AMDGPU_TARGET_ARRAY[@]}
  echo ""
fi

if [ $VERBOSE != 0 ]; then
  echo "new kernel args: ${LINK_KERNEL_ARGS[@]}"
  echo ""
  echo "new host args: ${LINK_HOST_ARGS[@]}"
  echo ""
  echo "new other args: ${LINK_OTHER_ARGS[@]}"
  echo ""
fi

# linker return value
ret=0

# only do kernel lowering if there are objects given
if [ ${#LINK_KERNEL_ARGS[@]} != 0 ]; then

  # touch an empty object for host part, to accomodate rule required by
  # clang-offload-bundler
  touch $TEMP_DIR/__empty.o

  # invoke clang-offload-bundler to create kernel bundle
  CLANG_OFFLOAD_BUNDLER_INPUTS_ARGS="-inputs=$TEMP_DIR/__empty.o"
  CLANG_OFFLOAD_BUNDLER_TARGETS_ARGS="-targets=host-@CMAKE_SYSTEM_PROCESSOR@-unknown-linux"

  if [ $KMTHINLTO == "1" ]; then
    _thinlto_path
  else
    _default_path
  fi

  if [ $VERBOSE != 0 ]; then
    echo "Finished generation of AMD GCN kernels"
  fi

  # invoke clang-offload-bundler
  $CLANG_OFFLOAD_BUNDLER -type=o $CLANG_OFFLOAD_BUNDLER_INPUTS_ARGS $CLANG_OFFLOAD_BUNDLER_TARGETS_ARGS -outputs=$TEMP_DIR/kernel.bundle

  # error handling
  ret=$?
  if [ $ret != 0 ]; then
    exit $ret
  fi

  if [ $KMDUMPBUNDLE == "1" ]; then
    cp $TEMP_DIR/kernel.bundle ./dump.bundle
  fi

  # build a new kernel object
  pushd . > /dev/null
  cd $TEMP_DIR
  $CLAMP_EMBED kernel.bundle kernel_hsa.o
  popd > /dev/null

  # link everything together
  ld --allow-multiple-definition $TEMP_DIR/kernel_hsa.o "${LINK_HOST_ARGS[@]}" "${LINK_CPU_ARG[@]}" "${LINK_OTHER_ARGS[@]}"
  ret=$?

fi # if [ -n $LINK_KERNEL_ARGS ];

# remove temp files
if [ -e $TEMP_DIR/kernel_hsa.o ]; then
  rm $TEMP_DIR/kernel_hsa.o
fi

if [ -e $TEMP_DIR/kernel_cpu.o ]; then
  rm $TEMP_DIR/kernel_cpu.o
fi

if [ -e $TEMP_DIR/__empty.o ]; then
  rm $TEMP_DIR/__empty.o
fi

if [ -e $TEMP_DIR/kernel.bundle ]; then
  rm $TEMP_DIR/kernel.bundle
fi

rm -f $TEMP_DIR/kernel-*.hsaco

if [ -e $TEMP_DIR/kernel.bc ]; then
  rm $TEMP_DIR/kernel.bc
fi

if [ ${#LINK_KERNEL_ARGS[@]} != 0 ]; then
  rm -f "${LINK_KERNEL_ARGS[@]}" # individual kernels
fi

if [ -n "$LINK_HOST_ARGS" ]; then
  rm -f "${LINK_HOST_ARGS[@]}" # individual host codes
fi

if [ -e $CXXAMP_SERIALIZE_SYMBOL_FILE ]; then
  rm $CXXAMP_SERIALIZE_SYMBOL_FILE # __cxxamp_serialize symbols
fi

for TD in "${TEMP_AR_DIRS[@]}"
do
  rm -rf $TD
done

if [ -d $TEMP_DIR ]; then
  rm -f $TEMP_DIR/*
  rmdir $TEMP_DIR
fi

# return value
exit $ret
