// xutility internal header
#pragma once
#ifndef _XUTILITY_
#define _XUTILITY_
#ifndef RC_INVOKED
#include <climits>
#include <cstdlib>
#include <utility>

 #pragma pack(push,_CRT_PACKING)
 #pragma warning(push,3)
 #pragma push_macro("new")
 #undef new

_STD_BEGIN
		// MACRO DEBUG_ERROR

 #if _ITERATOR_DEBUG_LEVEL == 2

  #define _DEBUG_ERROR(mesg)	\
	_DEBUG_ERROR2(mesg, __FILEW__, __LINE__)
  #define _DEBUG_ERROR2(mesg, file, line)	\
	_Debug_message(L ## mesg, file, line)

typedef const wchar_t *_Dbfile_t;
typedef unsigned int _Dbline_t;

_CRTIMP2_PURE void __CLRCALL_PURE_OR_CDECL _Debug_message(const wchar_t *,
	const wchar_t *, unsigned int);

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
  #define _DEBUG_ERROR(mesg)
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

		// CLASSES _Container_base*, _Iterator_base*
struct _CRTIMP2_PURE _Container_base0
	{	// base of all containers
	void _Orphan_all()
		{	// orphan all iterators
		}

	void _Swap_all(_Container_base0&)
		{	// swap all iterators
		}
	};

struct _Iterator_base0
	{	// base of all iterators
	void _Adopt(const void *)
		{	// adopt this iterator by parent
		}

	const _Container_base0 *_Getcont() const
		{	// get owning container
		return (0);
		}
	};

struct _Container_base12;
struct _Iterator_base12;

		// CLASS _Container_proxy
struct _Container_proxy
	{	// store head of iterator chain and back pointer
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	// construct from pointers
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _CRTIMP2_PURE _Container_base12
	{	// store pointer to _Container_proxy
public:
	_Container_base12()
		: _Myproxy(0)
		{	// construct childless container
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	// copy a container
		}

	_Container_base12& operator=(const _Container_base12&)
		{	// assign a container
		return (*this);
		}

	~_Container_base12() _NOEXCEPT
		{	// destroy the container
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	// get address of iterator chain
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	// orphan all iterators
	void _Swap_all(_Container_base12&);	// swap all iterators

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	// store links to container proxy, next iterator
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	// construct orphaned iterator
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	// copy an iterator
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	// assign an iterator
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	// becoming invalid, disown current parent
			_Lockit _Lock(_LOCK_DEBUG);
			_Orphan_me();
			}
		return (*this);
		}

	~_Iterator_base12() _NOEXCEPT
		{	// destroy the iterator
 #if _ITERATOR_DEBUG_LEVEL == 2
		_Lockit _Lock(_LOCK_DEBUG);
		_Orphan_me();
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	// adopt this iterator by parent
		if (_Parent == 0)
			{	// no future parent, just disown current parent
			_Lockit _Lock(_LOCK_DEBUG);
			_Orphan_me();
			}
		else
			{	// have a parent, do adoption
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 #if _ITERATOR_DEBUG_LEVEL == 2
			if (_Myproxy != _Parent_proxy)
				{	// change parentage
				_Lockit _Lock(_LOCK_DEBUG);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 #else /* _ITERATOR_DEBUG_LEVEL == 2 */
			_Myproxy = _Parent_proxy;
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
			}
		}

	void _Clrcont()
		{	// disown owning container
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	// get owning container
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	// get address of remaining iterator chain
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	// cut ties with parent
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Myproxy != 0)
			{	// adopted, remove self from list
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");
			*_Pnext = _Mynextiter;
			_Myproxy = 0;
			}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		// MEMBER FUNCTIONS FOR _Container_base12
inline void _Container_base12::_Orphan_all()
	{	// orphan all iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	if (_Myproxy != 0)
		{	// proxy allocated, drain it
		_Lockit _Lock(_LOCK_DEBUG);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = 0;
		_Myproxy->_Myfirstiter = 0;
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	// swap all iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	_Lockit _Lock(_LOCK_DEBUG);
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
typedef _Container_base12 _Container_base;
typedef _Iterator_base12 _Iterator_base;
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION _Is_checked AND FRIENDS

		// TEMPLATE STRUCT _Get_unchecked_type AND FRIENDS
 #define _UNCHECKED_TYPE(_Iter) \
	typename _Get_unchecked_type<_Iter>::type

		// TEMPLATE STRUCT _Get_unchecked_type
template<class _Ty>
	struct _Get_unchecked_type
		_GET_TYPE_OR_DEFAULT(_Unchecked_type,
			_Ty);

		// TEMPLATE STRUCT _Is_checked_helper
template<class _Ty>
	struct _Is_checked_helper
		_HAS_ONE_TYPE(_Unchecked_type);

		// TEMPLATE FUNCTION _Is_checked
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	// return type is derived from true_type if iterator is checked
	return (typename _Is_checked_helper<_Iter>::type());
	}

		// TEMPLATE FUNCTION _Unchecked
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	// construct unchecked from checked, generic
	return (_Src);
	}

		// TEMPLATE FUNCTION _Rechecked
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	// reset checked from unchecked, generic
	_Dest = _Src;
	return (_Dest);
	}

		//	ITERATOR STUFF (from <iterator>)
		// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag
	{	// identifying tag for input iterators
	};

struct output_iterator_tag
	{	// identifying tag for output iterators
	};

struct forward_iterator_tag
	: public input_iterator_tag, output_iterator_tag
	{	// identifying tag for forward iterators
	};

struct bidirectional_iterator_tag
	: public forward_iterator_tag
	{	// identifying tag for bidirectional iterators
	};

struct random_access_iterator_tag
	: public bidirectional_iterator_tag
	{	// identifying tag for random-access iterators
	};

		// POINTER ITERATOR TAGS
struct _Nonscalar_ptr_iterator_tag
	{	// pointer to unknown type
	};
struct _Scalar_ptr_iterator_tag
	{	// pointer to scalar type
	};

		// TEMPLATE CLASS iterator
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	// base type for iterator classes
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	// retained
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	// base type for debugging iterator classes
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;
	typedef _Diff distance_type;	// retained
	typedef _Pointer pointer;
	typedef _Reference reference;
	};

struct _Outit
	: public iterator<output_iterator_tag, void, void,
		void, void>
	{	// base for output iterators
	};

		// TEMPLATE CLASS iterator_traits
template<class _Iter>
	struct iterator_traits
	{	// get traits from iterator _Iter
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;
	typedef difference_type distance_type;	// retained
	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	// get traits from pointer
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	// retained
	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	// get traits from const pointer
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;
	typedef ptrdiff_t distance_type;	// retained
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		// TEMPLATE FUNCTION _Iter_cat
template<class _Iter> inline
	typename iterator_traits<_Iter>::iterator_category
		_Iter_cat(const _Iter&)
	{	// return category from iterator argument
	typename iterator_traits<_Iter>::iterator_category _Cat;
	return (_Cat);
	}

		// TEMPLATE FUNCTION _Ptr_cat
template<class _Iter1,
	class _Iter2> inline
	_Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)
	{	// return pointer category from arbitrary arguments
	_Nonscalar_ptr_iterator_tag _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2>
	struct _Ptr_cat_helper
	{	// determines pointer category, nonscalar by default
	typedef _Nonscalar_ptr_iterator_tag type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	// determines pointer category, common type
	typedef typename _If<is_scalar<_Elem>::value,
		_Scalar_ptr_iterator_tag,
		_Nonscalar_ptr_iterator_tag>::type type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	// determines pointer category
	typedef _Scalar_ptr_iterator_tag type;
	};

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(_Elem1 *, _Elem2 *)
	{	// return pointer category from pointers
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

template<class _Elem1,
	class _Elem2> inline
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type
		_Ptr_cat(const _Elem1 *, _Elem2 *)
	{	// return pointer category from pointers
	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
	return (_Cat);
	}

		// DEBUG TESTING MACROS

 #if _ITERATOR_DEBUG_LEVEL < 2
  #define _DEBUG_LT(x, y)	((x) < (y))
  #define _DEBUG_LT_PRED(pred, x, y)	pred(x, y)
  #define _DEBUG_ORDER(first, last)
  #define _DEBUG_ORDER_PRED(first, last, pred)
  #define _DEBUG_POINTER(first)
  #define _DEBUG_POINTER2(first, file, line)
  #define _DEBUG_RANGE(first, last)
  #define _DEBUG_RANGE2(first, last, file, line)

 #else /* _ITERATOR_DEBUG_LEVEL < 2 */

  #define _FILENAME	__FILEW__

  #ifndef _DEBUG_LT_IMPL
   #define _DEBUG_LT_IMPL	_Debug_lt
  #endif /* _DEBUG_LT_IMPL */

  #define _DEBUG_LT(x, y) \
	_DEBUG_LT_IMPL(x, y, _FILENAME, __LINE__)

  #ifndef _DEBUG_LT_PRED_IMPL
   #define _DEBUG_LT_PRED_IMPL	_Debug_lt_pred
  #endif /* _DEBUG_LT_PRED_IMPL */

  #define _DEBUG_LT_PRED(pred, x, y)	\
	_DEBUG_LT_PRED_IMPL(pred, x, y, _FILENAME, __LINE__)

  #ifndef _DEBUG_ORDER_IMPL
   #define _DEBUG_ORDER_IMPL	_Debug_order
  #endif /* _DEBUG_ORDER_IMPL */

  #define _DEBUG_ORDER(first, last)	\
	_DEBUG_ORDER_IMPL(first, last, _FILENAME, __LINE__)
  #define _DEBUG_ORDER_PRED(first, last, pred)	\
	_DEBUG_ORDER_IMPL(first, last, pred, _FILENAME, __LINE__)

  #ifndef _DEBUG_POINTER_IMPL
   #define _DEBUG_POINTER_IMPL	_Debug_pointer
  #endif /* _DEBUG_POINTER_IMPL */

  #define _DEBUG_POINTER(first)	\
	_DEBUG_POINTER_IMPL(first, _FILENAME, __LINE__)
  #define _DEBUG_POINTER2(first, file, line)	\
	_DEBUG_POINTER_IMPL(first, file, line)

  #ifndef _DEBUG_RANGE_IMPL
   #define _DEBUG_RANGE_IMPL	_Debug_range
  #endif /* _DEBUG_RANGE_IMPL */

  #define _DEBUG_RANGE(first, last)	\
	_DEBUG_RANGE_IMPL(first, last, _FILENAME, __LINE__)
  #define _DEBUG_RANGE2(first, last, file, line)	\
	_DEBUG_RANGE_IMPL(first, last, file, line)

		// TEMPLATE FUNCTION _Debug_lt
template<class _Ty1, class _Ty2> inline
	bool _Debug_lt(const _Ty1& _Left, const _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Left < _Right and operator< is strict weak ordering
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

template<class _Ty1, class _Ty2> inline
	bool _Debug_lt(const _Ty1& _Left, _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Left < _Right and operator< is strict weak ordering
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

template<class _Ty1, class _Ty2> inline
	bool _Debug_lt(_Ty1& _Left, const _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Left < _Right and operator< is strict weak ordering
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

template<class _Ty1, class _Ty2> inline
	bool _Debug_lt(_Ty1& _Left, _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Left < _Right and operator< is strict weak ordering
	if (!(_Left < _Right))
		return (false);
	else if (_Right < _Left)
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

		// TEMPLATE FUNCTION _Debug_lt_pred
template<class _Pr, class _Ty1, class _Ty2> inline
	bool _Debug_lt_pred(_Pr _Pred,
		const _Ty1& _Left, const _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

template<class _Pr, class _Ty1, class _Ty2> inline
	bool _Debug_lt_pred(_Pr _Pred,
		const _Ty1& _Left, _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

template<class _Pr, class _Ty1, class _Ty2> inline
	bool _Debug_lt_pred(_Pr _Pred,
		_Ty1& _Left, const _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

template<class _Pr, class _Ty1, class _Ty2> inline
	bool _Debug_lt_pred(_Pr _Pred,
		_Ty1& _Left, _Ty2& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if _Pred(_Left, _Right) and _Pred is strict weak ordering
	if (!_Pred(_Left, _Right))
		return (false);
	else if (_Pred(_Right, _Left))
		_DEBUG_ERROR2("invalid operator<", _File, _Line);
	return (true);
	}

		// TEMPLATE FUNCTION _Debug_pointer
template<class _InIt> inline
	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)
	{	// test pointer for non-singularity, arbitrary type
	}

template<class _Ty> inline
	void _Debug_pointer(const _Ty *_First, _Dbfile_t _File, _Dbline_t _Line)
	{	// test iterator for non-singularity, const pointers
	if (_First == 0)
		_DEBUG_ERROR2("invalid null pointer", _File, _Line);
	}

template<class _Ty> inline
	void _Debug_pointer(_Ty *_First, _Dbfile_t _File, _Dbline_t _Line)
	{	// test iterator for non-singularity, pointers
	if (_First == 0)
		_DEBUG_ERROR2("invalid null pointer", _File, _Line);
	}

		// TEMPLATE FUNCTION _Debug_range
template<class _InIt> inline
	void _Debug_range2(_InIt _First, _InIt _Last, _Dbfile_t, _Dbline_t,
		input_iterator_tag)
	{	// test iterator pair for valid range, arbitrary iterators
	bool _Ans = _First == _Last;	// make sure they're comparable
	_Ans = _Ans;	// to quiet diagnostics
	}

template<class _RanIt> inline
	void _Debug_range2(_RanIt _First, _RanIt _Last,
		_Dbfile_t _File, _Dbline_t _Line,
		random_access_iterator_tag)
	{	// test iterator pair for valid range, random-access iterators
	if (_First != _Last)
		{	// check for non-null pointers, valid range
		_DEBUG_POINTER2(_First, _File, _Line);
		_DEBUG_POINTER2(_Last, _File, _Line);
		if (_Last < _First)
			_DEBUG_ERROR2("invalid iterator range", _File, _Line);
		}
	}

template<class _InIt> inline
	void _Debug_range(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test iterator pair for valid range
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		// TEMPLATE FUNCTION _Debug_order
template<class _InIt> inline
	void _Debug_order2(_InIt, _InIt,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	// test if range is ordered by operator<, input iterators
	}

template<class _FwdIt> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	// test if range is ordered by operator<, forward iterators
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_DEBUG_LT(*_Next, *_First))
			_DEBUG_ERROR2("sequence not ordered", _File, _Line);
	}

template<class _InIt> inline
	void _Debug_order(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test is range is ordered by operator<
	_DEBUG_RANGE2(_First, _Last, _File, _Line);
	_Debug_order2(_First, _Last, _File, _Line, _Iter_cat(_First));
	}

		// TEMPLATE FUNCTION _Debug_order_pred
template<class _InIt,
	class _Pr> inline
	void _Debug_order2(_InIt, _InIt, _Pr,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	// test if range is ordered by predicate, input iterators
	}

template<class _FwdIt,
	class _Pr> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	// test if range is ordered by predicate, forward iterators
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_DEBUG_LT_PRED(_Pred, *_Next, *_First))
			_DEBUG_ERROR2("sequence not ordered", _File, _Line);
	}

template<class _InIt,
	class _Pr> inline
	void _Debug_order(_InIt _First, _InIt _Last, _Pr _Pred,
		_Dbfile_t _File, _Dbline_t _Line)
	{	// test if range is ordered by predicate
	_DEBUG_RANGE2(_First, _Last, _File, _Line);
	_DEBUG_POINTER2(_Pred, _File, _Line);
	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat(_First));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL < 2 */

		// MORE ITERATOR STUFF (from <iterator>)
		// TEMPLATE FUNCTION _Val_type

template<class _Iter> inline
	typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
	{	// return value type from arbitrary argument
	return (0);
	}

		// TEMPLATE FUNCTION advance
template<class _InIt,
	class _Diff> inline
	void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	// increment iterator by offset, input iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	if (_Off < 0)
		_DEBUG_ERROR("negative offset in advance");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _FwdIt,
	class _Diff> inline
	void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
	{	// increment iterator by offset, forward iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	if (_Off < 0)
		_DEBUG_ERROR("negative offset in advance");
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	// increment iterator by offset, bidirectional iterators
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	// increment iterator by offset, random-access iterators
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	// increment iterator by offset, arbitrary iterators
	_Advance(_Where, _Off, _Iter_cat(_Where));
	}

		// TEMPLATE FUNCTION _Dist_type

template<class _Iter> inline
	typename iterator_traits<_Iter>::difference_type
		*_Dist_type(_Iter)
	{	// return distance type from arbitrary argument
	return (0);
	}

		// TEMPLATE FUNCTIONS distance and _Distance
template<class _InIt,
	class _Diff> inline
		void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
			input_iterator_tag)
	{	// add to _Off distance between input iterators
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _FwdIt,
	class _Diff> inline
		void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
			forward_iterator_tag)
	{	// add to _Off distance between forward iterators (redundant)
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _BidIt,
	class _Diff> inline
		void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
			bidirectional_iterator_tag)
	{	// add to _Off distance between bidirectional iterators (redundant)
	for (; _First != _Last; ++_First)
		++_Off;
	}

template<class _RanIt,
	class _Diff> inline
		void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
			random_access_iterator_tag)
	{	// add to _Off distance between random-access iterators
 #if _ITERATOR_DEBUG_LEVEL == 2
	if (_First != _Last)
		{	// check for null pointers
		_DEBUG_POINTER(_First);
		_DEBUG_POINTER(_Last);
		}
 #endif /* _ITERATOR_DEBUG_LEVEL == 2 */

	_Off += _Last - _First;
	}

template<class _InIt> inline
	typename iterator_traits<_InIt>::difference_type
		distance(_InIt _First, _InIt _Last)
	{	// return distance between iterators
	typename iterator_traits<_InIt>::difference_type _Off = 0;
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	return (_Off);
	}

template<class _InIt,
	class _Diff> inline
		void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
	{	// add to _Off distance between iterators
	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
	}

 #if _HAS_CPP0X
		// TEMPLATE FUNCTION next
template<class _FwdIt> inline
	_FwdIt next(_FwdIt _First,
		typename iterator_traits<_FwdIt>::difference_type _Off = 1)
	{	// increment iterator
	static_assert((is_base_of<forward_iterator_tag,
		typename iterator_traits<_FwdIt>::iterator_category>::value),
		"next requires forward iterator");

	_STD advance(_First, _Off);
	return (_First);
	}

		// TEMPLATE FUNCTION prev
template<class _BidIt> inline
	_BidIt prev(_BidIt _First,
		typename iterator_traits<_BidIt>::difference_type _Off = 1)
	{	// decrement iterator
	static_assert((is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value),
		"prev requires bidirectional iterator");

	_STD advance(_First, -_Off);
	return (_First);
	}

template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	// get beginning of sequence
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	// get beginning of sequence
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	// get end of sequence
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	// get end of sequence
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	_Ty *begin(_Ty (&_Array)[_Size])
	{	// get beginning of array
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	_Ty *end(_Ty (&_Array)[_Size])
	{	// get end of array
	return (_Array + _Size);
	}
 #endif /* _HAS_CPP0X */

		// TEMPLATE CLASS _Revranit
template<class _Ty>
	struct pointer_traits;

template<class _RanIt,
	class _Base>
	class _Revranit
		: public _Base
	{	// wrap iterator to run it backwards
public:
	typedef _Revranit<_RanIt, _Base> _Myt;
 	typedef typename _Base::difference_type difference_type;
	typedef typename _Base::pointer pointer;
	typedef typename _Base::reference reference;
	typedef _RanIt iterator_type;

	_Revranit()
		{	// construct with default wrapped iterator
		}

	explicit _Revranit(_RanIt _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _RanIt2,
		class _Base2>
		_Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	_RanIt base() const
		{	// return wrapped iterator
		return (current);
		}

	reference operator*() const
		{	// return designated value
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (_STD pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	// preincrement
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	template<class _RanIt2,
		class _Base2>
		bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
		{	// test for iterator equality
		return (current == _Right.base());
		}

// N.B. functions valid for random-access iterators only beyond this point

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	template<class _RanIt2,
		class _Base2>
		bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
		{	// test if this < _Right
		return (_Right.base() < current);
		}

	difference_type operator-(const _Myt& _Right) const
		{	// return difference of iterators
		return (_Right.base() - current);
		}

protected:
	_RanIt current;	// the wrapped iterator
	};

		// _Revranit TEMPLATE OPERATORS
template<class _RanIt,
	class _Base,
	class _Diff> inline
	_Revranit<_RanIt, _Base>
		operator+(_Diff _Off,
		const _Revranit<_RanIt, _Base>& _Right)
	{	// return reverse_iterator + integer
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2>
	auto inline operator-(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	// return difference of reverse_iterators
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator==(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	// test for reverse_iterator equality
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator!=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	// test for reverse_iterator inequality
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator<(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	// test for reverse_iterator < reverse_iterator
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator>(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	// test for reverse_iterator > reverse_iterator
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator<=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	// test for reverse_iterator <= reverse_iterator
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _Base1,
	class _RanIt2,
	class _Base2> inline
	bool operator>=(
		const _Revranit<_RanIt1, _Base1>& _Left,
		const _Revranit<_RanIt2, _Base2>& _Right)
	{	// test for reverse_iterator >= reverse_iterator
	return (!(_Left < _Right));
	}

		// TEMPLATE CLASS reverse_iterator
template<class _RanIt>
	class reverse_iterator
		: public _Revranit<_RanIt, iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference> >
	{	// wrap iterator to run it backwards
	typedef reverse_iterator<_RanIt> _Myt;
	typedef _Revranit<_RanIt, iterator<
		typename iterator_traits<_RanIt>::iterator_category,
		typename iterator_traits<_RanIt>::value_type,
		typename iterator_traits<_RanIt>::difference_type,
		typename iterator_traits<_RanIt>::pointer,
		typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
 	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		{	// construct with default wrapped iterator
		}

	explicit reverse_iterator(_RanIt _Right)
		: _Mybase(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: _Mybase(_Right.base())
		{	// initialize with compatible base
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	// assign with compatible base
		this->current = _Right.base();
		return (*this);
		}

	reverse_iterator(_Mybase _Right)
		: _Mybase(_Right)
		{	// construct wrapped iterator from base object
		}

	_Myt& operator++()
		{	// preincrement
		++*((_Mybase *)this);
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		--*((_Mybase *)this);
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		*((_Mybase *)this) += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		*((_Mybase *)this) -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	// mark reverse_iterator as checked if its wrapped iterator is checked
	};

		// reverse_iterator TEMPLATE OPERATORS
template<class _RanIt,
	class _Diff> inline
	reverse_iterator<_RanIt> operator+(_Diff _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	// return reverse_iterator + integer
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	// return difference of reverse_iterators
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator equality
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator inequality
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator < reverse_iterator
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator > reverse_iterator
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator <= reverse_iterator
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	// test for reverse_iterator >= reverse_iterator
	return (!(_Left < _Right));
	}

		// TEMPLATE CLASS _Array_const_iterator
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	// iterator for nonmutable array
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
	enum {_EEN_IDL =
		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator

 #if _ITERATOR_DEBUG_LEVEL == 0
	_Array_const_iterator()
		{	// construct with null pointer
		_Ptr = 0;
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		{	// construct with pointer and offset
		_Ptr = _Parg + _Off;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	// reset from unchecked iterator
		_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	// make an unchecked iterator
		return (_Ptr);
		}

	reference operator*() const
		{	// return designated object
		return (*_Ptr);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (_STD pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	// preincrement
		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	// postincrement
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	// predecrement
		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	// postdecrement
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	// increment by integer
		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	// return this + integer
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	// return this - integer
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	// return difference of iterators
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	// test for iterator equality
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	// test if this < _Right
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

	pointer _Ptr;	// beginning of array

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
	_Array_const_iterator()
		{	// construct with null pointer
		_Ptr = 0;
		_Idx = 0;
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		{	// construct with pointer and offset
		_Ptr = _Parg;
		_Idx = _Off;
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	// reset from unchecked iterator
		_Idx = _Right - _Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	// make an unchecked iterator
		return (_Ptr + _Idx);
		}

	reference operator*() const
		{	// return designated object
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	// report error
			_DEBUG_ERROR("array iterator not dereferencable");
			_SCL_SECURE_OUT_OF_RANGE;
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
		_SCL_SECURE_VALIDATE(_Ptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */

		_Analysis_assume_(_Ptr != 0);

		return (_Ptr[_Idx]);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (_STD pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	// preincrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	// report error
			_DEBUG_ERROR("array iterator not incrementable");
			_SCL_SECURE_OUT_OF_RANGE;
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
		_SCL_SECURE_VALIDATE(_Ptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(_Idx < _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */

		++_Idx;
		return (*this);
		}

	_Myiter operator++(int)
		{	// postincrement
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	// predecrement
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Ptr == 0
			|| _Idx <= 0)
			{	// report error
			_DEBUG_ERROR("array iterator not decrementable");
			_SCL_SECURE_OUT_OF_RANGE;
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
		_SCL_SECURE_VALIDATE(_Ptr != 0);
		_SCL_SECURE_VALIDATE_RANGE(0 < _Idx);
 #endif /* _ITERATOR_DEBUG_LEVEL */

		--_Idx;
		return (*this);
		}

	_Myiter operator--(int)
		{	// postdecrement
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	// increment by integer
 #if _ITERATOR_DEBUG_LEVEL == 2
		if (_Size < _Idx + _Off)
			{	// report error
			_DEBUG_ERROR("array iterator + offset out of range");
			_SCL_SECURE_OUT_OF_RANGE;
			}

 #elif _ITERATOR_DEBUG_LEVEL == 1
		_SCL_SECURE_VALIDATE_RANGE(_Idx + _Off <= _Size);
 #endif /* _ITERATOR_DEBUG_LEVEL */

		_Idx += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	// return this + integer
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	// return this - integer
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	// return difference of iterators
		_Compat(_Right);
		return (_Idx < _Right._Idx
			? -(difference_type)(_Right._Idx - _Idx)
			: (difference_type)_Idx - _Right._Idx);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	// test for iterator equality
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	bool operator!=(const _Myiter& _Right) const
		{	// test for iterator inequality
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	// test if this < _Right
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	bool operator>(const _Myiter& _Right) const
		{	// test if this > _Right
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	// test if this <= _Right
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	// test if this >= _Right
		return (!(*this < _Right));
		}

 #if _ITERATOR_DEBUG_LEVEL == 2
	void _Compat(const _Myiter& _Right) const
		{	// test for compatible iterator pair
		if (_Ptr != _Right._Ptr)
			{	// report error
			_DEBUG_ERROR("array iterators incompatible");
			_SCL_SECURE_INVALID_ARGUMENT;
			}
		}

 #elif _ITERATOR_DEBUG_LEVEL == 1
	void _Compat(const _Myiter& _Right) const
		{	// test for compatible iterator pair
		_SCL_SECURE_VALIDATE_RANGE(_Ptr == _Right._Ptr);
		}
 #endif /* _ITERATOR_DEBUG_LEVEL */

	pointer _Ptr;	// beginning of array
	size_t _Idx;	// offset into array
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	// convert to unchecked
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	// convert to checked
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// TEMPLATE CLASS _Array_iterator
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	// iterator for mutable array
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	// construct with null pointer
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	// construct with pointer and offset
		}
	enum {_EEN_SIZE = _Size};	// helper for expression evaluator
	enum {_EEN_IDL =
		_ITERATOR_DEBUG_LEVEL};	// helper for expression evaluator

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	// reset from unchecked iterator
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	// make an unchecked iterator
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	// return designated object
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	// return pointer to class object
		return (_STD pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	// preincrement
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	// postincrement
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	// predecrement
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	// postdecrement
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	// increment by integer
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	// return this + integer
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	// decrement by integer
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	// return this - integer
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	// return difference of iterators
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	// convert to unchecked
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	// convert to checked
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	// add offset to iterator
	return (_Next += _Off);
	}

		// TEMPLATE CLASS move_iterator
template<class _RanIt>
	class move_iterator
	{	// wrap iterator to move rvalues
public:
	typedef move_iterator<_RanIt> _Myt;
 	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
 	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
 	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef value_type&& reference;
	typedef _RanIt iterator_type;

	move_iterator()
		{	// construct with default wrapped iterator
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	// construct wrapped iterator from _Right
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	// initialize with compatible base
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	// assign with compatible base
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	// return wrapped iterator
		return (current);
		}

	reference operator*() const
		{	// return designated value
		return (_STD move(*current));
		}

	pointer operator->() const
		{	// return pointer to class object
		return (current);
		}

	_Myt& operator++()
		{	// preincrement
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	// postincrement
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	// predecrement
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	// postdecrement
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	// test for iterator equality
		return (current == _Right.base());
		}

// N.B. functions valid for random-access iterators only beyond this point

	_Myt& operator+=(difference_type _Off)
		{	// increment by integer
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	// return this + integer
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	// decrement by integer
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	// return this - integer
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	// subscript
		return (_STD move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	// test if this < _Right
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	// return difference of iterators
		return (current - _Right.base());
		}

protected:
	iterator_type current;	// the wrapped iterator
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	// mark move_iterator as checked if its wrapped iterator is checked
	};

		// move_iterator TEMPLATE OPERATORS
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	// return move_iterator + integer
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	// test for move_iterator equality
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator equality
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator inequality
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator < move_iterator
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator > move_iterator
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator <= move_iterator
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	// test for move_iterator >= move_iterator
	return (!(_Left < _Right));
	}

		// TEMPLATE FUNCTION make_move_iterator
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	// make move_iterator from iterator
	return (move_iterator<_RanIt>(_Iter));
	}

		//	ALGORITHM STUFF (from <algorithm>)
		// TEMPLATE FUNCTION max
template<class _Ty> inline

	_Post_equal_to_(_Left < _Right ? _Right : _Left)

	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
	{	// return larger of _Left and _Right
	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION max WITH PRED
template<class _Ty,
	class _Pr> inline
	const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return larger of _Left and _Right using _Pred
	return (_DEBUG_LT_PRED(_Pred, _Left, _Right) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION min
template<class _Ty> inline

	_Post_equal_to_(_Right < _Left ? _Right : _Left)

	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
	{	// return smaller of _Left and _Right
	return (_DEBUG_LT(_Right, _Left) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION min WITH PRED
template<class _Ty,
	class _Pr> inline
	const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return smaller of _Left and _Right using _Pred
	return (_DEBUG_LT_PRED(_Pred, _Right, _Left) ? _Right : _Left);
	}

		// TEMPLATE FUNCTION minmax
template<class _Ty> inline
	pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right)
	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right
	return (_Right < _Left
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

		// TEMPLATE FUNCTION minmax WITH PRED
template<class _Ty,
	class _Pr> inline
	pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	// return pair(leftmost/smaller, rightmost/larger) of _Left and _Right
	return (_Pred(_Right, _Left)
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

		// TEMPLATE FUNCTION copy
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars
	ptrdiff_t _Count = _Last - _First;
	_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
	return (_Copy_impl(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
	return (_Rechecked(_Dest,
		_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, output_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators
	return (_Copy_impl(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Copy_impl(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, true_type)
	{	// copy [_First, _Last) to [_Dest, ...), checked dest
	return (_Copy_impl(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
_SCL_INSECURE_DEPRECATE
	_OutIt _Copy_impl(_InIt _First, _InIt _Last,
		_OutIt _Dest, false_type)
	{	// copy [_First, _Last) to [_Dest, ...), unchecked dest
	return (_Copy_impl(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// copy [_First, _Last) to [_Dest, ...)
	if (_First == _Last)
		return (_Dest);
	else
		{	// worth copying, check then copy
		_DEBUG_RANGE(_First, _Last);
		_DEBUG_POINTER(_Dest);
		return (_Copy_impl(_Unchecked(_First), _Unchecked(_Last),
			_Dest, _Is_checked(_Dest)));
		}
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _Last) to [_Dest, ...)
	return (_Unchecked(
		_STD copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

 #if _HAS_CPP0X
		// TEMPLATE FUNCTION copy_n
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), input iterators
	*_Dest = *_First;	// 0 < _Count has been guaranteed
	while (0 < --_Count)
		*++_Dest = *++_First;
	return (++_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), forward iterators
	for (; 0 < _Count; --_Count, ++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary iterators
	return (_Copy_n(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), pointers to scalars
	_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked
	return (_Copy_n(_First, _Count,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Rechecked(_Dest,
			_Copy_n(_Unchecked(_First), _Count,
				_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
		_OutIt _Dest, output_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary dest
	return (_Copy_n(_First, _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n2(_InIt _First, _Diff _Count,
		_OutIt _Dest, random_access_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access dest
	_OutIt _Ans = _Dest + _Count;	// also checks range
	_Copy_n(_First, _Count,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), arbitrary input
	return (_Copy_n2(_First, _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n1(_InIt _First, _Diff _Count,
		_OutIt _Dest, random_access_iterator_tag)
	{	// copy [_First, _First + _Count) to [_Dest, ...), random-access input
	_InIt _Last = _First + _Count;	// also checks range
	_Last = _Last;	// to quiet diagnostics
	return (_Copy_n2(_Unchecked(_First), _Count,
		_Dest, _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, true_type)
	{	// copy [_First, _First + _Count) to [_Dest, ...), checked dest
	return (_Copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
_SCL_INSECURE_DEPRECATE
	_OutIt _Copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest, false_type)
	{	// copy [_First, _First + _Count) to [_Dest, ...), unchecked dest
	return (_Copy_n1(_First, _Count,
		_Dest, _Iter_cat(_First)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...)
	_DEBUG_POINTER(_First);
	_DEBUG_POINTER(_Dest);
	if (_Count <= 0)
		return (_Dest);
	else
		return (_Copy_n(_First, _Count,
			_Dest, _Is_checked(_Dest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutIt _Dest)
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input
	return (_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
		_Dest));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array dest
	return (_Unchecked(
		_STD copy_n(_First, _Count,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	// copy [_First, _First + _Count) to [_Dest, ...), array input/dest
	return (_Unchecked(
		_STD copy_n(_Array_iterator<_InTy, _InSize>(_First), _Count,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
 #endif /* _HAS_CPP0X */

		// TEMPLATE FUNCTION copy_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars
	ptrdiff_t _Count = _Last - _First;
	_CSTD memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked
	return (_Copy_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// copy [_First, _Last) backwards to [..., _Dest)
	return (_Rechecked(_Dest,
		_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, true_type)
	{	// copy [_First, _Last) backwards to [..., _Dest), checked dest
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
_SCL_INSECURE_DEPRECATE
	_BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, false_type)
	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked dest
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// copy [_First, _Last) backwards to [..., _Dest)
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Copy_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION move
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Nonscalar_ptr_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
	for (; _First != _Last; ++_Dest, ++_First)
		*_Dest = _STD move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), pointers to scalars
	ptrdiff_t _Count = _Last - _First;
	_CSTD memmove(&*_Dest, &*_First,
		_Count * sizeof (*_First));
	return (_Dest + _Count);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...), unchecked
	return (_Move(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...)
	return (_Rechecked(_Dest,
		_Move(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, output_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators
	return (_Move(_First, _Last,
		_Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	// move [_First, _Last) to [_Dest, ...), random-access iterators
	_OutIt _Ans = _Dest + (_Last - _First);	// also checks range
	_Move(_First, _Last,
		_Unchecked(_Dest));
	return (_Ans);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, true_type)
	{	// move [_First, _Last) to [_Dest, ...), checked dest
	return (_Move(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
_SCL_INSECURE_DEPRECATE
	_OutIt _Move(_InIt _First, _InIt _Last,
		_OutIt _Dest, false_type)
	{	// move [_First, _Last) to [_Dest, ...), unchecked dest
	return (_Move(_First, _Last,
		_Dest, _Iter_cat(_First), _Iter_cat(_Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	// move [_First, _Last) to [_Dest, ...)
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Move(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *move(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	// move [_First, _Last) to [_Dest, ...)
	return (_Unchecked(
		_STD move(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION move_backward
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
	{	// move [_First, _Last) backwards to [..., _Dest), arbitrary iterators
	while (_First != _Last)
		*--_Dest = _STD move(*--_Last);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_backward(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Scalar_ptr_iterator_tag)
	{	// move [_First, _Last) backwards to [..., _Dest), pointers to scalars
	ptrdiff_t _Count = _Last - _First;
	_CSTD memmove(&*_Dest - _Count, &*_First,
		_Count * sizeof (*_First));
	return (_Dest - _Count);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest), unchecked
	return (_Move_backward(_First, _Last,
		_Dest, _Ptr_cat(_First, _Dest)));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest)
	return (_Rechecked(_Dest,
		_Move_backward(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest))));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, true_type)
	{	// move [_First, _Last) backwards to [..., _Dest), checked dest
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
_SCL_INSECURE_DEPRECATE
	_BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, false_type)
	{	// move [_First, _Last) backwards to [..., _Dest), unchecked dest
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	// move [_First, _Last) backwards to [..., _Dest)
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Dest);
	return (_Move_backward(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Is_checked(_Dest)));
	}
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION fill
template<class _FwdIt,
	class _Ty> inline
	void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last)
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

inline void _Fill(char *_First, char *_Last, char _Val)
	{	// copy char _Val through [_First, _Last)
	_CSTD memset(_First, _Val, _Last - _First);
	}

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
	{	// copy signed char _Val through [_First, _Last)
	_CSTD memset(_First, _Val, _Last - _First);
	}

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
	{	// copy unsigned char _Val through [_First, _Last)
	_CSTD memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	// copy _Val through [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		// TEMPLATE FUNCTION fill_n
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...)
	for (; 0 < _Count; --_Count, ++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
	{	// copy char _Val _Count times through [_Dest, ...)
	_CSTD memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
	signed char _Val)
	{	// copy signed char _Val _Count times through [_Dest, ...)
	_CSTD memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
	unsigned char _Val)
	{	// copy unsigned char _Val _Count times through [_Dest, ...)
	_CSTD memset(_Dest, _Val, _Count);
	return (_Dest + _Count);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...)
	return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		output_iterator_tag)
	{	// copy _Val _Count times through [_Dest, ...), arbitrary iterator
	return (_Fill_n(_Dest, _Count, _Val));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n1(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		random_access_iterator_tag)
	{	// copy _Val _Count times through [_Dest, ...), random-access iterator
	_OutIt _Ans = _Dest + _Count;	// also checks range
	_Fill_n(_Unchecked(_Dest), _Count, _Val);
	return (_Ans);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		true_type)
	{	// copy _Val _Count times through [_Dest, ...), checked dest
	return (_Fill_n1(_Dest, _Count, _Val,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
_SCL_INSECURE_DEPRECATE
	_OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val,
		false_type)
	{	// copy _Val _Count times through [_Dest, ...), unchecked dest
	return (_Fill_n1(_Dest, _Count, _Val,
		_Iter_cat(_Dest)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...)
	_DEBUG_POINTER(_Dest);
	return (_Fill_n(_Dest, _Count, _Val,
		_Is_checked(_Dest)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Ty> inline
	_OutTy *fill_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, const _Ty& _Val)
	{	// copy _Val _Count times through [_Dest, ...)
	return (_Unchecked(_STD fill_n(_Array_iterator<_OutTy, _OutSize>(_Dest),
		_Count, _Val)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION mismatch
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	for (; _First1 != _Last1 && *_First1 == *_First2; )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_First2));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		_Mismatch1(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, true_type)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input
	return (_Mismatch(_First1, _Last1,
		_First2));
	}

template<class _InIt1,
	class _InIt2> inline
_SCL_INSECURE_DEPRECATE
	pair<_InIt1, _InIt2>
		_Mismatch1(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, false_type)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input
	return (_Mismatch(_First1, _Last1,
		_First2));
	}

template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_First2);
	pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(
		_Mismatch1(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Is_checked(_First2)));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize])
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, array input
	pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(
		_STD mismatch(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2)));
	return (pair<_InIt1, _InTy *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION mismatch WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		++_First1, ++_First2;
	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(
		_Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred, true_type)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, checked input
	return (_Mismatch(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
_SCL_INSECURE_DEPRECATE
	pair<_InIt1, _InIt2>
		_Mismatch2(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred, false_type)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch, unchecked input
	return (_Mismatch(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_First2);
	_DEBUG_POINTER(_Pred);
	pair<_UNCHECKED_TYPE(_InIt1), _InIt2> _Ans(
		_Mismatch2(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred, _Is_checked(_First2)));
	return (pair<_InIt1, _InIt2>(
		_Rechecked(_First1, _Ans.first),
		_Ans.second));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize], _Pr _Pred)
	{	// return [_First1, _Last1)/[_First2, ...) mismatch using _Pred
	pair<_InIt1, _Array_iterator<_InTy, _InSize> > _Ans(
		_STD mismatch(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	return (pair<_InIt1, _InTy *>(
		_Ans.first,
		_Unchecked(_Ans.second)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION equal
template<class _InIt1,
	class _InIt2> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
	{	// compare [_First1, _Last1) to [First2, ...)
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!(*_First1 == *_First2))
			return (false);
	return (true);
	}

inline bool _Equal(const char *_First1, const char *_Last1,
	const char *_First2)
	{	// compare [_First1, _Last1) to [First2, ...), for chars
	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
	const signed char *_First2)
	{	// compare [_First1, _Last1) to [First2, ...), for signed chars
	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2)
	{	// compare [_First1, _Last1) to [First2, ...), for unsigned chars
	return (_CSTD memcmp(_First1, _First2, _Last1 - _First1) == 0);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	// compare [_First1, _Last1) to [First2, ...)
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2)));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2> inline
	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, true_type)
	{	// compare [_First1, _Last1) to [First2, ...), checked dest
	return (_Equal(_First1, _Last1,
		_First2));
	}

template<class _InIt1,
	class _InIt2> inline
_SCL_INSECURE_DEPRECATE
	bool _Equal1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, false_type)
	{	// compare [_First1, _Last1) to [First2, ...), unchecked dest
	return (_Equal(_First1, _Last1,
		_First2));
	}

template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	// compare [_First1, _Last1) to [First2, ...)
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_First2);
	return (_Equal1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Is_checked(_First2)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	// compare [_First1, _Last1) to [First2, ...)
	return (_STD equal(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2)));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION equal WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [First2, ...) using _Pred
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

 #if _ITERATOR_DEBUG_LEVEL == 0
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [First2, ...)
	return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred));
	}

 #else /* _ITERATOR_DEBUG_LEVEL == 0 */
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, true_type)
	{	// compare [_First1, _Last1) to [First2, ...), checked input
	return (_Equal(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
_SCL_INSECURE_DEPRECATE
	bool _Equal2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred, false_type)
	{	// compare [_First1, _Last1) to [First2, ...), unchecked input
	return (_Equal(_First1, _Last1,
		_First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	// compare [_First1, _Last1) to [First2, ...)
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_First2);
	return (_Equal2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Is_checked(_First2)));
	}

 #if _ITERATOR_DEBUG_ARRAY_OVERLOADS
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	// compare [_First1, _Last1) to [First2, ...)
	return (_STD equal(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #endif /* _ITERATOR_DEBUG_ARRAY_OVERLOADS */
 #endif /* _ITERATOR_DEBUG_LEVEL == 0 */

		// TEMPLATE FUNCTION lexicographical_compare
template<class _InIt1,
	class _InIt2> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// order [_First1, _Last1) vs. [First2, Last2)
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_DEBUG_LT(*_First1, *_First2))
			return (true);
		else if (*_First2 < *_First1)
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

inline bool _Lexicographical_compare(
	const unsigned char *_First1, const unsigned char *_Last1,
	const unsigned char *_First2, const unsigned char *_Last2)
	{	// order [_First1, _Last1) vs. [First2, Last2), for unsigned char
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
	}

 #if CHAR_MAX == UCHAR_MAX
inline bool _Lexicographical_compare(
	const char *_First1, const char *_Last1,
	const char *_First2, const char *_Last2)
	{	// order [_First1, _Last1) vs. [First2, Last2), for nonnegative char
	ptrdiff_t _Num1 = _Last1 - _First1;
	ptrdiff_t _Num2 = _Last2 - _First2;
	int _Ans = _CSTD memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Ans < 0 || _Ans == 0 && _Num1 < _Num2);
	}
 #endif /* CHAR_MAX == UCHAR_MAX */

template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	// order [_First1, _Last1) vs. [First2, Last2)
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2)));
	}

		// TEMPLATE FUNCTION lexicographical_compare WITH PRED
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (_DEBUG_LT_PRED(_Pred, *_First1, *_First2))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	// order [_First1, _Last1) vs. [First2, Last2) using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_RANGE(_First2, _Last2);
	_DEBUG_POINTER(_Pred);
	return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		// TEMPLATE FUNCTION find
template<class _InIt,
	class _Ty> inline
	_InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

inline const char *_Find(const char *_First, const char *_Last, int _Val)
	{	// find first char that matches _Val
	_First = (const char *)_CSTD memchr(_First, _Val, _Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const signed char *_Find(const signed char *_First,
	const signed char *_Last, int _Val)
	{	// find first signed char that matches _Val
	_First = (const signed char *)_CSTD memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

inline const unsigned char *_Find(const unsigned char *_First,
	const unsigned char *_Last, int _Val)
	{	// find first unsigned char that matches _Val
	_First = (const unsigned char *)_CSTD memchr(_First, _Val,
		_Last - _First);
	return (_First == 0 ? _Last : _First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	// find first matching _Val
	_DEBUG_RANGE(_First, _Last);
	return (_Rechecked(_First,
		_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		// TEMPLATE FUNCTION _Find_pr WITH PREDICATE
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// find first matching _Val, using _Pred
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		// TEMPLATE FUNCTION count
template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	// count elements that match _Val
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	typename iterator_traits<_InIt>::difference_type
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	// count elements that match _Val
	_DEBUG_RANGE(_First, _Last);
	return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		// TEMPLATE FUNCTION _Count_pr WITH PREDICATE
template<class _InIt,
	class _Ty,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
	{	// count elements that match _Val, using _Pred
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

 #if _HAS_CPP0X
		// TEMPLATE FUNCTION is_permutation
template<class _FwdIt1,
	class _FwdIt2> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	// test if [_First1, _Last1) == permuted [_First2, ...)
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!(*_First1 == *_First2))
			break;	// find first inequality
	if (_First1 != _Last1)
		{	// check match counts in suffix
		_FwdIt2 _Last2 = _First2;
		advance(_Last2, distance(_First1, _Last1));
		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
			if (_Next1 == _Find(_First1, _Next1, *_Next1))
				{	// new value, compare match counts
				typename iterator_traits<_FwdIt2>::difference_type _Count =
					_Count_np(_First2, _Last2, *_Next1);
				if (_Count == 0
					|| _Count != _Count_np(_Next1, _Last1, *_Next1))
					return (false);	// match counts differ, fail
				}
		}
	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	// test if [_First1, _Last1) == permuted [_First2, ...)
	_DEBUG_RANGE(_First1, _Last1);
	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2));
	}

		// TEMPLATE FUNCTION is_permutation WITH PREDICATE
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	// test if [_First1, _First2) == permuted [_First2, ...), using _Pred
	for (; _First1 != _Last1; ++_First1, ++_First2)
		if (!_Pred(*_First1, *_First2))
			break;	// find first inequality
	if (_First1 != _Last1)
		{	// check match counts in suffix
		_FwdIt2 _Last2 = _First2;
		advance(_Last2, distance(_First1, _Last1));
		for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
			if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
				{	// new value, compare match counts
				typename iterator_traits<_FwdIt2>::difference_type _Count =
					_Count_pr(_First2, _Last2, *_Next1, _Pred);
				if (_Count == 0
					|| _Count != _Count_pr(_Next1, _Last1, *_Next1, _Pred))
					return (false);	// match counts differ, fail
				}
		}
	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	// test if [_First1, _First2) == permuted [_First2, ...), using _Pred
	_DEBUG_RANGE(_First1, _Last1);
	_DEBUG_POINTER(_Pred);
	return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Pred);
	}
 #endif /* _HAS_CPP0X */

		// TEMPLATE FUNCTION reverse
template<class _BidIt> inline
	void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
	{	// reverse elements in [_First, _Last), bidirectional iterators
	for (; _First != _Last && _First != --_Last; ++_First)
		_STD iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	// reverse elements in [_First, _Last)
	_DEBUG_RANGE(_First, _Last);
	_Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
	}

		// TEMPLATE FUNCTION rotate
template<class _FwdIt> inline
	void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	// rotate [_First, _Last), forward iterators
	for (_FwdIt _Next = _Mid; ; )
		{	// swap [_First, ...) into place
		_STD iter_swap(_First, _Next);
		if (++_First == _Mid)
			if (++_Next == _Last)
				break;	// done, quit
			else
				_Mid = _Next;	// mark end of next interval
		else if (++_Next == _Last)
			_Next = _Mid;	// wrap to last end
		}
	}

template<class _BidIt> inline
	void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	// rotate [_First, _Last), bidirectional iterators
	_STD reverse(_First, _Mid);
	_STD reverse(_Mid, _Last);
	_STD reverse(_First, _Last);
	}

template<class _RanIt,
	class _Diff,
	class _Ty> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
	{	// rotate [_First, _Last), random-access iterators
	_Diff _Shift = _Mid - _First;
	_Diff _Count = _Last - _First;

	for (_Diff _Factor = _Shift; _Factor != 0; )
		{	// find subcycle count as GCD of shift count and length
		_Diff _Tmp = _Count % _Factor;
		_Count = _Factor;
		_Factor = _Tmp;
		}

	if (_Count < _Last - _First)
		for (; 0 < _Count; --_Count)
			{	// rotate each subcycle
			_RanIt _Hole = _First + _Count;
			_RanIt _Next = _Hole;
			_RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
			for (; ; )
				{	// percolate elements back around subcycle
				iter_swap(_Next, _Next1);
				_Next = _Next1;
				_Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
					: _First + (_Shift - (_Last - _Next1));
				if (_Next1 == _Hole)
					break;
				}
			}
	}

template<class _RanIt> inline
	void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	// rotate [_First, _Last), random-access iterators
	_Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	// rotate [_First, _Last)
	_DEBUG_RANGE(_First, _Mid);
	_DEBUG_RANGE(_Mid, _Last);
	if (_First != _Mid && _Mid != _Last)
		_Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
			_Iter_cat(_First));
	_STD advance(_First, _STD distance(_Mid, _Last));
	return (_First);
	}

	// TEMPLATE CLASS _Rng_from_urng
template<class _Diff, class _Urng>
	class _Rng_from_urng
	{	// wrap a URNG as an RNG
public:
 #if _HAS_CPP0X
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;

 #else /* _HAS_CPP0X */
	typedef size_t _Udiff;
 #endif /* _HAS_CPP0X */

	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(CHAR_BIT * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	// construct from URNG
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	// adapt _Urng closed range to [0, _Index)
		for (; ; )
			{	// try a sample random value
			_Udiff _Ret = 0;	// random bits
			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

			while (_Mask < _Udiff(_Index - 1))
				{	// need more random bits
				_Ret <<= _Bits;
				_Ret |= _Get_bits();
				_Mask <<= _Bits;
				_Mask |= _Bmask;
				}

			// _Ret is [0, _Mask],  _Index - 1 <= _Mask, return if unbiased
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	// return a random value
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);
			_Num += _Bits)
			{	// don't mask away any bits
			_Ret <<= _Bits;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

private:
	_Udiff _Get_bits()
		{	// return a random value within [0, _Bmask]
		for (; ; )
			{	// repeat until random value is in range
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	// reference to URNG
	size_t _Bits;	// number of random bits generated by _Get_bits()
	_Udiff _Bmask;	// 2^_Bits - 1

	_Rng_from_urng(const _Rng_from_urng&);	// not defined
	_Rng_from_urng& operator=(const _Rng_from_urng&);	// not defined
	};

		// TEMPLATE CLASS _Yarn
template<class _Elem>
	class _CRTIMP2_PURE _Yarn
	{	// wrap a NTBS
public:
	typedef _Yarn<_Elem> _Myt;

	__CLR_OR_THIS_CALL _Yarn()
		: _Myptr(0), _Nul(0)
		{	// default construct
		}

	__CLR_OR_THIS_CALL _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	// construct from _Yarn
		*this = _Right;
		}

	__CLR_OR_THIS_CALL _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	// construct from NTBS
		*this = _Right;
		}

	_Myt& __CLR_OR_THIS_CALL operator=(const _Myt& _Right)
		{	// assign from _Yarn
		return (*this = _Right._Myptr);
		}

	_Myt& __CLR_OR_THIS_CALL operator=(const _Elem *_Right)
		{	// assign from NTBS
		if (_Myptr != _Right)
			{	// new value, discard old and copy new
			_Tidy();

			if (_Right != 0)
				{	// new is not empty, copy it
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 #ifdef _DEBUG
				_Myptr = (_Elem *)_malloc_dbg(_Count, _CRT_BLOCK,
					__FILE__, __LINE__);

 #else /* _DEBUG */
				_Myptr = (_Elem *)_CSTD malloc(_Count);
 #endif /* _DEBUG */

				if (_Myptr != 0)
					_CSTD memcpy(_Myptr, _Right, _Count);
				}
			}
		return (*this);
		}

	__CLR_OR_THIS_CALL ~_Yarn() _NOEXCEPT
		{	// destroy the object
		_Tidy();
		}

	bool __CLR_OR_THIS_CALL empty() const
		{	// test if empty string
		return (_Myptr == 0);
		}

	const _Elem *__CLR_OR_THIS_CALL c_str() const
		{	// return NTBS
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool __CLR_OR_THIS_CALL _Empty() const
		{	// test if empty string
		return (_Myptr == 0);
		}

	const _Elem *__CLR_OR_THIS_CALL _C_str() const
		{	// return NTBS
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void __CLR_OR_THIS_CALL _Tidy()
		{	// discard any string
		if (_Myptr != 0)

 #ifdef _DEBUG
			_free_dbg(_Myptr, _CRT_BLOCK);

 #else /* _DEBUG */
			_CSTD free(_Myptr);
 #endif /* _DEBUG */

		_Myptr = 0;
		}

	_Elem *_Myptr;	// pointer to allocated string
	_Elem _Nul;		// nul terminator for unallocated string
	};

	// TEMPLATE STRUCT _Has_allocator_type
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	// tests for suitable _Ty::allocator_type
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		// STRUCT allocator_arg_t
struct allocator_arg_t
	{	// tag type for added allocator argument
	};

const allocator_arg_t allocator_arg = allocator_arg_t();

_CRTIMP2_PURE _NO_RETURN(__CLRCALL_PURE_OR_CDECL _Xbad_alloc());
_CRTIMP2_PURE _NO_RETURN(__CLRCALL_PURE_OR_CDECL _Xinvalid_argument(_In_z_ const char *));
_CRTIMP2_PURE _NO_RETURN(__CLRCALL_PURE_OR_CDECL _Xlength_error(_In_z_ const char *));
_CRTIMP2_PURE _NO_RETURN(__CLRCALL_PURE_OR_CDECL _Xout_of_range(_In_z_ const char *));
_CRTIMP2_PURE _NO_RETURN(__CLRCALL_PURE_OR_CDECL _Xoverflow_error(_In_z_ const char *));
_CRTIMP2_PURE _NO_RETURN(__CLRCALL_PURE_OR_CDECL _Xruntime_error(_In_z_ const char *));
_STD_END

 #if _HAS_CPP0X
namespace std {
		// TEMPLATE STRUCT uses_allocator
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	// determine whether _Ty has an allocator_type member type
	};
}	// namespace std
 #endif /* _HAS_CPP0X */

 #pragma pop_macro("new")
 #pragma warning(pop)
 #pragma pack(pop)
#endif /* RC_INVOKED */
#endif /* _XUTILITY_ */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */

/*
 * Copyright (c) 1992-2012 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
V6.00:0009 */
